# Вы не знаете JS: Приступим!
## Код
*исходный код* или просто *код* — это набор особых инструкций, сообщающих компьютеру какие задачи нужно сделать.

Правила допустимого формата и комбинаций операторов называются *язык программирования*, иногда их соотносят с его *синтаксисом*.

### Операторы

В языке программирования группа слов, чисел и операций, которые выполняют определенную задачу, называются *оператором*. В JavaScript, оператор может выглядеть так:

```js
a = b * 2;
```

Символы `a` и `b` называются *переменными* (см. «Переменные»). В программах переменные хранят значения (например, число `42`), используемые программой.

В противоположность им, `2` — это само значение, называемое *литеральным значением*, поскольку оно само по себе и не хранится в переменной.

Символы `=` и `*` — это *операции* (см. «Операции»), они выполняют действия со значениями и переменными, такие как присваивание и математическое умножение.

Большинство операторов в JavaScript заканчиваются точкой с запятой (`;`).

Программы — это всего лишь набор стольких операторов, сколько нужно для того, чтобы описать все шаги, необходимые для выполнения цели вашей программы.

### Выражения

Операторы состоят из одного или более *выражений*. Выражение — это любая ссылка на переменную или значение или набор переменных и значений, объединенных операциями.

Например:

```js
a = b * 2;
```

У этого оператора 4 выражения:

* `2` — это *выражение литерального значения*
* `b` — это *выражение переменной*, которое тут означает извлечение его текущего значения
* `b * 2` — это *арифметическое выражение*, в данном случае выполнение умножения
* `a = b * 2` — это *выражение присваивания*, в данном случае это присвоить результат выражения `b * 2` переменной `a` (подробнее о выражениях далее)

Типичное выражение, которое является законченным, называется *оператор-выражение*, например, такое как это:

```js
b * 2;
```

Этот пример оператора-выражения не является типовым или полезным, и в целом не оказывает никакого эффекта на выполнение программы — он всего лишь извлекает значение `b` и умножает его на `2`, но затем ничего не делает с результатом.

Более распространенный оператор-выражение — это *оператор-выражение вызова*  (см. «Функции»), поскольку весь оператор — это выражение вызова функции:

```js
alert( a );
```

### Выполнение программы

Так как же эти наборы программных операторов сообщают компьютеру что нужно делать? Программу нужно *выполнить*, также говорят *запуск программы*.

Операторы, подобные `a = b * 2`, понятны для разработчиков как при чтении, так и записи, но фактически в такой форме они не понятны напрямую компьютеру. Поэтому используется специальная утилита в компьютере (либо *интерпретатор*, либо *компилятор*) для перевода кода, который вы пишете, в команды, понятные компьютеру.

В некоторых языках программирования перевод команд обычно выполняется сверху вниз, строка за строкой, каждый раз когда программа запускается, что обычно называется *интерпретацией* кода.

В других языках, перевод, выполняемый заранее, называется *компиляцией* кода, поэтому когда позднее программа *запускается*, то, что запускается — это по факту уже скомпилированные инструкции компьютера, готовые к выполнению.

Обычно утверждают, что JavaScript — *интерпретируемый*, так как ваш исходный код на JavaScript обрабатывается каждый раз, когда запускается. Но это не совсем точно. Движок JavaScript на самом деле *компилирует* программу на лету и затем сразу же запускает скомпилированный код.

**Примечание:** Подробнее о компиляции JavaScript смотрите в первых двух главах книги *Область видимости и замыкания* этой серии.

## Операции

Операции — это те действия, которые мы выполняем над переменными и значениями. Мы уже видели две операции JavaScript, `=` и `*`.

Операция `*` выполняет математическое умножение. Достаточно просто, не так ли?

Операция `=` используется для *присваивания* — сначала мы вычисляем значение с *правой стороны* (исходное значение) от `=`, а затем записываем его в переменную, которую мы указываем с *левой стороны* (переменная назначения).

Пример:

```js
a = 2;
b = a + 1;
```
Вот несколько самых базовых операций в JavaScript:

* Присваивание: `=` как в `a = 2`.
* Математические: `+` (сложение), `-` (вычитание), `*` (умножение) и  `/` (деление), как в `a * 3`.
* Составное присваивание: `+=`, `-=`, `*=`, and `/=` — это составные операции, которые объединяют математическую операцию с присваиванием, как в `a += 2` (эквивалентно `a = a + 2`).
* Инкремент/Декремент: `++` (инкремент), `--` (декремент), как в `a++` (эквивалентно `a = a + 1`).
* Доступ к свойству объекта: `.` как в `console.log()`.

   Объекты — это значения, которые хранят другие значения под своими именами, называемые свойства. `obj.a` означает значение из объекта  `obj` из его свойства `a`. Еще один способ доступа к свойствам — `obj["a"]`. См. главу 2.
* Равенство: `==` (нестрогое), `===` (строгое), `!=` (нестрогое неравенство), `!==` (строгое неравенство), как в `a == b`.

   См. «Значения и типы» и главу 2.
* Сравнение: `<` (меньше чем), `>` (больше чем), `<=` (меньше или нестрого равно), `>=` (больше или нестрого равно), как в `a <= b`.

   См. «Значения и типы» и главу 2.
* Логические: `&&` (и), `||` (или), как в `a || b`, которое выбирает или `a`, *или* (*or*) `b`.

   Эти операции используются для создания составных условных конструкций (см. «Условные конструкции»), например: если либо `a` *либо (*or*)* `b` — истина.

**Примечание:** Для более детального рассмотрения и охвата операций, не рассмотренных здесь, см. the Mozilla Developer Network (MDN)'s “Expressions and Operators“ (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators).

## Значения и типы

Значения, непосредственно включаемые в исходный код, называются *литералы*. `строковые` литералы заключаются в двойные кавычки `"..."` или одинарные (`'...'`) — единственная разница в них — это ваши стилистические предпочтения. Литералы `числа` и `логического значения` пишутся как есть (т.е., `42`, `true` и т.д.).

Пример:

```js
"Я - строка";
'Я - тоже строка';

42;

true;
```

Кроме типов значений `строка`/`число`/`логическое значение`, для языков программирования привычно предоставлять такие типы как  *массивы*, *объекты*, *функции* и многое другое. Мы рассмотрим детально значения и типы на протяжении этой и следующей глав.

### Преобразование между типами

Если у вас есть `число`, но вам надо вывести его на экран, вам нужно преобразовать его значение в `строку` и в JavaScript такая конвертация называется «приведение (coercion)». Аналогично, если кто-то вводит серию цифр в форму на веб-странице, это `строка`, но если нужно потом использовать это значение для выполнения математических операций, то вам понадобится *приведение* его к `числу`.

JavaScript предоставляет несколько различных возможностей принудительного приведения между *типами*. Например:

```js
var a = "42";
var b = Number( a );

console.log( a );	// "42"
console.log( b );	// 42
```

Использование `Number(..)` (встроенная функция), как было показано выше, это *явное* приведение из любого другого типа в тип `число`. Это выглядит достаточно очевидно.

Но каверзный вопрос заключается в том, что произойдет когда вы попытаетесь сравнить два значения разных типов, которые могут потребовать *неявного* приведения.

При сравнении строки `"99.99"` с числом `99.99` многие согласятся, что они равны. Но они ведь не совсем одно и то же, не так ли? Это одно и то же значение в двух разных представлениях, двух разных *типов*. Вы могли бы сказать, что они «нестрого равны», разве нет?

Чтобы помочь вам в таких стандартных ситуациях, JavaScript иногда вмешивается и *неявно* приводит значения к подходящим типам.

Поэтому если вы используете операцию нестрогого равенства `==` для сравнения `"99.99" == 99.99`, JavaScript преобразует с левой стороны `"99.99"` в его `числовой` эквивалент `99.99`. После этого сравнение превращается в `99.99 == 99.99`, которое конечно является `истинным`.

Несмотря на то, что неявное приведение было задумано, чтобы помочь вам, оно может привести в замешательство, если вы не уделили достаточно времени изучению правил, которые определяют его поведение.  У большинства JS-разработчиков никогда его нет, поэтому общее отношение выражается в том, что неявное приведение сбивает с толку и вредит программам внося непредвиденные ошибки и поэтому следует его избегать. Иногда его даже называют изъяном дизайна языка.

Однако, неявное приведение — это механизм, который *может быть изучен* и даже более того *должен быть изучен* любым, кто хочет серьезно заниматься программированием на JavaScript. Не только потому, что после изучения его правил оно не будет смущать вас, оно может в самом деле улучшить ваши программы! Усилия того стоят!

## Комментарии в коде
В JavaScript есть два типа комментариев: однострочный комментарий и многострочный комментарий.

Пример:

```js
// Это - однострочный комментарий

/* А это
       многострочный
             комментарий.
                      */
```

Однострочный комментарий `//` подходит если вы собираетесь разместить комментарий прямо над одиночным оператором или даже в конце строки. Всё что написано в строке после `//` интерпретируется как комментарий (и потому игнорируется компилятором) до самого конца строки.

Пример:

```js
var a = 42;		// 42 - смысл жизни
```

Многострочный комментарий `/* .. */` подходит в случае, если у вас есть несколько строк пояснений для вашего кода.

Вот типичный пример использования многострочного комментария:

```js
/* Нижеприведенное значение используется, поскольку
   выяснилось, что оно отвечает
   на любой вопрос во вселенной. */
var a = 42;
```

Он может появляться в любом месте строки, даже в середине строки, поскольку есть `*/`, обозначающий его окончание. Например:

```js
var a = /* произвольное значение */ 42;

console.log( a );	// 42
```

## Переменные

Большинству программ нужно отслеживать то, как меняется значение на протяжении выполнения программы, проходя через различные операции, вызываемые для соответствующих задач вашей программы.

Самый простой путь сделать это в программе — это присвоить значение символьному контейнеру, называемому *переменной*, называющейся так потому, что значение в этом контейнере может *меняться* с течением времени при необходимости.

В некоторых языках программирования вы определяете переменную (контейнер), чтобы хранить определенный тип значения, такой как `число` или `строка`. *Статическая типизация*, также известная как  *контроль типов*, обычно упоминается как преимущество в корректности программы, предотвращая непредусмотренные преобразования значений.

Другие языки выводят типы для значений вместо переменных. *Слабая типизация*, также известная как *динамическая типизация*, позволяет переменной хранить значения любого типа в любое время. Это обычно упоминается как преимущество в гибкости программы позволяя одной переменной представлять значение вне зависимости от того, в форме какого типа это значение может понадобиться в любой момент выполнения программы.

JavaScript использует второй подход, *динамическую типизацию*, что означает, что переменные могут хранить значения любого *типа* без какого-либо контроля *типов*.

Как уже упоминалось ранее, мы объявляем переменную используя оператор `var`, заметьте, что при этом нет больше никакой другой информации о *типе* в объявлении. Обратите внимание на эту простую программу:

```js
var amount = 99.99;

amount = amount * 2;

console.log( amount );		// 199.98

// преобразует `amount` в строку и
// добавляет "$" в начало
amount = "$" + String( amount );

console.log( amount );		// "$199.98"
```

Переменная `amount` начинает свой жизненный цикл с хранения числа `99.99`, а затем хранит `числовой` результат `amount * 2`, который равен `199.98`.

Первая команда `console.log(..)` должна *неявно* привести это `числовое` значение к `строке`, чтобы вывести его в консоль.

Затем оператор `amount = "$" + String(amount)` *явно* приводит значение `199.98` к `строке` и добавляет символ `"$"` в начало. С этого момента, `amount` хранит `строковое` значение `"$199.98"`, поэтому второму оператору `console.log(..)` не нужно выполнять никакого приведения, чтобы вывести его в консоль.

Разработчики на JavaScript отметят гибкость использования переменной  `amount` для каждого из значений `99.99`, `199.98` и `"$199.98"`. Энтузиасты статической типизации предпочтут отдельную переменную, например `amountStr`, чтобы хранить окончательное представление значения `"$199.98"`, поскольку оно уже будет другого типа.

В любом случае, вы заметите, что `amount` хранит текущее значение, которое меняется по ходу выполнения программы, иллюстрируя первичную цель переменных: управление *состоянием* программы.

Другими словами, *состояние* отслеживает изменения значений при выполнении программы.

Еще одно общеупотребительное использование переменных — для централизации установки значений. Обычно это называется *константами*, когда вы объявляете переменную со значением и предполагаете, что это значение не будет меняться в течение работы программы.

Вы объявляете эти *константы*, чаще всего в начале программы, таким образом, чтобы для вас было удобно иметь всего одно место для того, чтобы поменять значение, если нужно. По соглашению, переменные в JavaScript, являющиеся константами, обычно пишутся большими буквами, с подчеркиваниями `_` между словами.

Вот глупый пример:

```js
var TAX_RATE = 0.08;	// 8% налог с продаж

var amount = 99.99;

amount = amount * 2;

amount = amount + (amount * TAX_RATE);

console.log( amount );				// 215.9784
console.log( amount.toFixed( 2 ) );	// "215.98"
```

**Примечание:** Также как `console.log(..)` — это функция `log(..)`, доступная как свойство объекта `console`, `toFixed(..)` здесь — это функция, которая может быть доступна у `числовых` значений. `Число` в JavaScript не форматируется автоматически со знаком валюты — среда выполнения не знает ваших намерений плюс к этому не существует типа для валюты. `toFixed(..)` позволяет нам указать до скольки знаков после запятой мы хотим округлить `число` и она возвращает `строку` при необходимости.

Переменная `TAX_RATE` — всего лишь *константа* по соглашению, в этой программе нет ничего, что могло бы предотвратить ее изменение. Но если ставка налога повысится до 9%, мы все еще можем легко обновить нашу программу установив присвоенное `TAX_RATE` значение в `0.09` всего в одном месте вместо поиска всех вхождений значения `0.08` разбросанных по программе и изменения их всех.

Новейшая версия JavaScript на момент написания этих строк (обычно называемая "ES6") включает в себя новый способ объявления *констант*, используя `const` вместо `var`:

```js
// согласно ES6:
const TAX_RATE = 0.08;

var amount = 99.99;

// ..
```

Константы полезны также как и переменные с неизменяемыми значениями, за исключением того, что константы также предотвращают случайное изменение где-либо после начальной установки значения. Если вы попытаетесь присвоить любое значение в `TAX_RATE` после её объявления, ваша программа отвергнет это изменение (а в строгом (strict) режиме, прервется с ошибкой, см. "Строгий режим" в главе 2).

Кстати, такой тип «защиты» против ошибок похож на контроль типов статической типизации, так что вы в какой-то степени поймете почему статические типы в других языках могут быть привлекательными!

**Примечание:** Для получения более подробной информации о том, как различные значения в переменных могут использоваться в программах, см. книгу *Типы и синтаксис* этой серии.

## Блоки

В JavaScript блок определяется обрамлением одного или более операторов парой фигурных скобок `{ .. }`. Пример:

```js
var amount = 99.99;

// отдельный блок
{
	amount = amount * 2;
	console.log( amount );	// 199.98
}
```

Такой вид отдельного блока `{ .. }` вполне допустим, но не часто встречается в JS-программах. Обычно блоки присоединяются к другим управляющим операторам, таким как оператор `if` (см. «Условные конструкции») или цикл (см. «Циклы»).

**Примечание:** В отличие от многих других операторов, таких как `console.log(amount);`, блоковый оператор не требует точки с запятой (`;`) в конце оператора.

## Циклы

При большой посещаемости магазина есть очередь из покупателей, которым нужно поговорить с сотрудником магазина. Пока в этой очереди есть люди, сотруднику нужно продолжать обслуживать очередного покупателя.

Повторение набора действий пока не нарушится определенное условие, другими словами, повторение только пока соблюдается условие — это как раз работа для циклов. Циклы могут принимать различные формы, но все они удовлетворяют этому базовому поведению.

Цикл включает в себя проверяемое условие и блок (обычно в виде `{ .. }`). Каждый раз, когда выполняется блок в цикле, это называется  *итерацией*.

Например, цикл `while` и цикл `do..while` иллюстрируют принцип повторения блока операторов до тех пора пока условие не перестанет быть равным `true`:

```js
while (numOfCustomers > 0) {
	console.log( "Чем я могу вам помочь?" );

	// помощь покупателю...

	numOfCustomers = numOfCustomers - 1;
}

// против:

do {
	console.log( "Чем я могу вам помочь?" );

	// помощь покупателю...

	numOfCustomers = numOfCustomers - 1;
} while (numOfCustomers > 0);
```

Единственная разница между этими циклами — это будет ли проверяться условная конструкция до первой итерации (`while`) или после первой итерации (`do..while`).

В любом из этих циклов если условная конструкция возвратит `false`, следующая итерация не будет выполнена. Это значит, что если условие изначально будет `false`, цикл `while` никогда не будет выполнен, а цикл `do..while` выполнится только один раз.

Иногда вы используете цикл для подсчета определенного набора чисел, например от `0` до `9` (десять чисел). Это можно сделать установкой переменной в цикле итерации, например  `i`, в значение `0` и увеличивая его на `1` в каждой итерации.

Для выхода из цикла можно использовать JavaScript-оператор `break`. К тому же, можно обнаружить, что ужасно легко можно создать цикл, который в противном случае будет работать вечно без механизма  `break`.

Проиллюстрируем:

```js
var i = 0;

// цикл `while..true` будет выполняться вечно, не так ли?
while (true) {
	// прервать цикл?
	if ((i <= 9) === false) {
		break;
	}

	console.log( i );
	i = i + 1;
}
// 0 1 2 3 4 5 6 7 8 9
```

**Предупреждение:** Показанное выше не является практикой, которой вы должны придерживаться при реализации ваших циклов. Это представлено только в иллюстративных целях.

Если `while` (или `do..while`) может достичь цели вручную, есть еще одна синтаксическая форма, называемая цикл `for` именно для такой вот цели:

```js
for (var i = 0; i <= 9; i = i + 1) {
	console.log( i );
}
// 0 1 2 3 4 5 6 7 8 9
```

Как видите, в обоих случаях условная конструкция `i <= 9` равна `true` для первых 10 итераций (`i` принимает значения от `0` до `9`) любой из форм цикла, но становится равным `false` как только `i` становится равным `10`.

У цикла `for` есть три составных части: инициализация (`var i=0`), проверка условия (`i <= 9`) и обновление значения (`i = i + 1`). Поэтому если вы собираетесь заниматься выполнением конкретного количества итераций, `for` будет более компактной и часто более легкой формой цикла для понимания и записи.

Есть другие особые формы циклов, которые предназначены для итерирования по особым значениям, таким как свойства объекта (см. главу 2), где неявная проверка условной конструкции — это все ли свойства или нет уже обработаны. Принцип «цикл работает пока не нарушится условие» соблюдается независимо от формы цикла.

## Функции
Функция — обычно это именованная секция кода, которая может быть «вызвана» по имени и код внутри нее будет при этом запускаться каждый раз. Пример:

```js
function printAmount() {
	console.log( amount.toFixed( 2 ) );
}

var amount = 99.99;

printAmount(); // "99.99"

amount = amount * 2;

printAmount(); // "199.98"
```

У функций могут быть аргументы (т.е. параметры) — это значения которые вы ей передаете. А также функции могут возвращать значение.

```js
function printAmount(amt) {
	console.log( amt.toFixed( 2 ) );
}

function formatAmount() {
	return "$" + amount.toFixed( 2 );
}

var amount = 99.99;

printAmount( amount * 2 );		// "199.98"

amount = formatAmount();
console.log( amount );			// "$99.99"
```

Функции часто используются для кода, который вы планируете вызывать несколько раз, но они также полезны для организации связанных частей кода в именованные наборы, даже если вы будете вызывать их всего лишь раз.

