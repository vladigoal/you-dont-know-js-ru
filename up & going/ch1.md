# Вы не знаете JS: Приступим!
## Код
*исходный код* или просто *код* — это набор особых инструкций, сообщающих компьютеру какие задачи нужно сделать.

Правила допустимого формата и комбинаций операторов называются *язык программирования*, иногда их соотносят с его *синтаксисом*.

### Операторы

В языке программирования группа слов, чисел и операций, которые выполняют определенную задачу, называются *оператором*. В JavaScript, оператор может выглядеть так:

```js
a = b * 2;
```

Символы `a` и `b` называются *переменными* (см. «Переменные»). В программах переменные хранят значения (например, число `42`), используемые программой.

В противоположность им, `2` — это само значение, называемое *литеральным значением*, поскольку оно само по себе и не хранится в переменной.

Символы `=` и `*` — это *операции* (см. «Операции»), они выполняют действия со значениями и переменными, такие как присваивание и математическое умножение.

Большинство операторов в JavaScript заканчиваются точкой с запятой (`;`).

Программы — это всего лишь набор стольких операторов, сколько нужно для того, чтобы описать все шаги, необходимые для выполнения цели вашей программы.

### Выражения

Операторы состоят из одного или более *выражений*. Выражение — это любая ссылка на переменную или значение или набор переменных и значений, объединенных операциями.

Например:

```js
a = b * 2;
```

У этого оператора 4 выражения:

* `2` — это *выражение литерального значения*
* `b` — это *выражение переменной*, которое тут означает извлечение его текущего значения
* `b * 2` — это *арифметическое выражение*, в данном случае выполнение умножения
* `a = b * 2` — это *выражение присваивания*, в данном случае это присвоить результат выражения `b * 2` переменной `a` (подробнее о выражениях далее)

Типичное выражение, которое является законченным, называется *оператор-выражение*, например, такое как это:

```js
b * 2;
```

Этот пример оператора-выражения не является типовым или полезным, и в целом не оказывает никакого эффекта на выполнение программы — он всего лишь извлекает значение `b` и умножает его на `2`, но затем ничего не делает с результатом.

Более распространенный оператор-выражение — это *оператор-выражение вызова*  (см. «Функции»), поскольку весь оператор — это выражение вызова функции:

```js
alert( a );
```

### Выполнение программы

Так как же эти наборы программных операторов сообщают компьютеру что нужно делать? Программу нужно *выполнить*, также говорят *запуск программы*.

Операторы, подобные `a = b * 2`, понятны для разработчиков как при чтении, так и записи, но фактически в такой форме они не понятны напрямую компьютеру. Поэтому используется специальная утилита в компьютере (либо *интерпретатор*, либо *компилятор*) для перевода кода, который вы пишете, в команды, понятные компьютеру.

В некоторых языках программирования перевод команд обычно выполняется сверху вниз, строка за строкой, каждый раз когда программа запускается, что обычно называется *интерпретацией* кода.

В других языках, перевод, выполняемый заранее, называется *компиляцией* кода, поэтому когда позднее программа *запускается*, то, что запускается — это по факту уже скомпилированные инструкции компьютера, готовые к выполнению.

Обычно утверждают, что JavaScript — *интерпретируемый*, так как ваш исходный код на JavaScript обрабатывается каждый раз, когда запускается. Но это не совсем точно. Движок JavaScript на самом деле *компилирует* программу на лету и затем сразу же запускает скомпилированный код.

**Примечание:** Подробнее о компиляции JavaScript смотрите в первых двух главах книги *Область видимости и замыкания* этой серии.

## Операции

Операции — это те действия, которые мы выполняем над переменными и значениями. Мы уже видели две операции JavaScript, `=` и `*`.

Операция `*` выполняет математическое умножение. Достаточно просто, не так ли?

Операция `=` используется для *присваивания* — сначала мы вычисляем значение с *правой стороны* (исходное значение) от `=`, а затем записываем его в переменную, которую мы указываем с *левой стороны* (переменная назначения).

Пример:

```js
a = 2;
b = a + 1;
```
Вот несколько самых базовых операций в JavaScript:

* Присваивание: `=` как в `a = 2`.
* Математические: `+` (сложение), `-` (вычитание), `*` (умножение) и  `/` (деление), как в `a * 3`.
* Составное присваивание: `+=`, `-=`, `*=`, and `/=` — это составные операции, которые объединяют математическую операцию с присваиванием, как в `a += 2` (эквивалентно `a = a + 2`).
* Инкремент/Декремент: `++` (инкремент), `--` (декремент), как в `a++` (эквивалентно `a = a + 1`).
* Доступ к свойству объекта: `.` как в `console.log()`.

   Объекты — это значения, которые хранят другие значения под своими именами, называемые свойства. `obj.a` означает значение из объекта  `obj` из его свойства `a`. Еще один способ доступа к свойствам — `obj["a"]`. См. главу 2.
* Равенство: `==` (нестрогое), `===` (строгое), `!=` (нестрогое неравенство), `!==` (строгое неравенство), как в `a == b`.

   См. «Значения и типы» и главу 2.
* Сравнение: `<` (меньше чем), `>` (больше чем), `<=` (меньше или нестрого равно), `>=` (больше или нестрого равно), как в `a <= b`.

   См. «Значения и типы» и главу 2.
* Логические: `&&` (и), `||` (или), как в `a || b`, которое выбирает или `a`, *или* (*or*) `b`.

   Эти операции используются для создания составных условных конструкций (см. «Условные конструкции»), например: если либо `a` *либо (*or*)* `b` — истина.

**Примечание:** Для более детального рассмотрения и охвата операций, не рассмотренных здесь, см. the Mozilla Developer Network (MDN)'s “Expressions and Operators“ (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators).

## Значения и типы

Значения, непосредственно включаемые в исходный код, называются *литералы*. `строковые` литералы заключаются в двойные кавычки `"..."` или одинарные (`'...'`) — единственная разница в них — это ваши стилистические предпочтения. Литералы `числа` и `логического значения` пишутся как есть (т.е., `42`, `true` и т.д.).

Пример:

```js
"Я - строка";
'Я - тоже строка';

42;

true;
```

Кроме типов значений `строка`/`число`/`логическое значение`, для языков программирования привычно предоставлять такие типы как  *массивы*, *объекты*, *функции* и многое другое. Мы рассмотрим детально значения и типы на протяжении этой и следующей глав.

### Преобразование между типами

Если у вас есть `число`, но вам надо вывести его на экран, вам нужно преобразовать его значение в `строку` и в JavaScript такая конвертация называется «приведение (coercion)». Аналогично, если кто-то вводит серию цифр в форму на веб-странице, это `строка`, но если нужно потом использовать это значение для выполнения математических операций, то вам понадобится *приведение* его к `числу`.

JavaScript предоставляет несколько различных возможностей принудительного приведения между *типами*. Например:

```js
var a = "42";
var b = Number( a );

console.log( a );	// "42"
console.log( b );	// 42
```

Использование `Number(..)` (встроенная функция), как было показано выше, это *явное* приведение из любого другого типа в тип `число`. Это выглядит достаточно очевидно.

Но каверзный вопрос заключается в том, что произойдет когда вы попытаетесь сравнить два значения разных типов, которые могут потребовать *неявного* приведения.

При сравнении строки `"99.99"` с числом `99.99` многие согласятся, что они равны. Но они ведь не совсем одно и то же, не так ли? Это одно и то же значение в двух разных представлениях, двух разных *типов*. Вы могли бы сказать, что они «нестрого равны», разве нет?

Чтобы помочь вам в таких стандартных ситуациях, JavaScript иногда вмешивается и *неявно* приводит значения к подходящим типам.

Поэтому если вы используете операцию нестрогого равенства `==` для сравнения `"99.99" == 99.99`, JavaScript преобразует с левой стороны `"99.99"` в его `числовой` эквивалент `99.99`. После этого сравнение превращается в `99.99 == 99.99`, которое конечно является `истинным`.

Несмотря на то, что неявное приведение было задумано, чтобы помочь вам, оно может привести в замешательство, если вы не уделили достаточно времени изучению правил, которые определяют его поведение.  У большинства JS-разработчиков никогда его нет, поэтому общее отношение выражается в том, что неявное приведение сбивает с толку и вредит программам внося непредвиденные ошибки и поэтому следует его избегать. Иногда его даже называют изъяном дизайна языка.

Однако, неявное приведение — это механизм, который *может быть изучен* и даже более того *должен быть изучен* любым, кто хочет серьезно заниматься программированием на JavaScript. Не только потому, что после изучения его правил оно не будет смущать вас, оно может в самом деле улучшить ваши программы! Усилия того стоят!

## Комментарии в коде
В JavaScript есть два типа комментариев: однострочный комментарий и многострочный комментарий.

Пример:

```js
// Это - однострочный комментарий

/* А это
       многострочный
             комментарий.
                      */
```

Однострочный комментарий `//` подходит если вы собираетесь разместить комментарий прямо над одиночным оператором или даже в конце строки. Всё что написано в строке после `//` интерпретируется как комментарий (и потому игнорируется компилятором) до самого конца строки.

Пример:

```js
var a = 42;		// 42 - смысл жизни
```

Многострочный комментарий `/* .. */` подходит в случае, если у вас есть несколько строк пояснений для вашего кода.

Вот типичный пример использования многострочного комментария:

```js
/* Нижеприведенное значение используется, поскольку
   выяснилось, что оно отвечает
   на любой вопрос во вселенной. */
var a = 42;
```

Он может появляться в любом месте строки, даже в середине строки, поскольку есть `*/`, обозначающий его окончание. Например:

```js
var a = /* произвольное значение */ 42;

console.log( a );	// 42
```

## Переменные

Большинству программ нужно отслеживать то, как меняется значение на протяжении выполнения программы, проходя через различные операции, вызываемые для соответствующих задач вашей программы.

Самый простой путь сделать это в программе — это присвоить значение символьному контейнеру, называемому *переменной*, называющейся так потому, что значение в этом контейнере может *меняться* с течением времени при необходимости.

В некоторых языках программирования вы определяете переменную (контейнер), чтобы хранить определенный тип значения, такой как `число` или `строка`. *Статическая типизация*, также известная как  *контроль типов*, обычно упоминается как преимущество в корректности программы, предотвращая непредусмотренные преобразования значений.

Другие языки выводят типы для значений вместо переменных. *Слабая типизация*, также известная как *динамическая типизация*, позволяет переменной хранить значения любого типа в любое время. Это обычно упоминается как преимущество в гибкости программы позволяя одной переменной представлять значение вне зависимости от того, в форме какого типа это значение может понадобиться в любой момент выполнения программы.

JavaScript использует второй подход, *динамическую типизацию*, что означает, что переменные могут хранить значения любого *типа* без какого-либо контроля *типов*.

Как уже упоминалось ранее, мы объявляем переменную используя оператор `var`, заметьте, что при этом нет больше никакой другой информации о *типе* в объявлении. Обратите внимание на эту простую программу:

```js
var amount = 99.99;

amount = amount * 2;

console.log( amount );		// 199.98

// преобразует `amount` в строку и
// добавляет "$" в начало
amount = "$" + String( amount );

console.log( amount );		// "$199.98"
```

Переменная `amount` начинает свой жизненный цикл с хранения числа `99.99`, а затем хранит `числовой` результат `amount * 2`, который равен `199.98`.

Первая команда `console.log(..)` должна *неявно* привести это `числовое` значение к `строке`, чтобы вывести его в консоль.

Затем оператор `amount = "$" + String(amount)` *явно* приводит значение `199.98` к `строке` и добавляет символ `"$"` в начало. С этого момента, `amount` хранит `строковое` значение `"$199.98"`, поэтому второму оператору `console.log(..)` не нужно выполнять никакого приведения, чтобы вывести его в консоль.

Разработчики на JavaScript отметят гибкость использования переменной  `amount` для каждого из значений `99.99`, `199.98` и `"$199.98"`. Энтузиасты статической типизации предпочтут отдельную переменную, например `amountStr`, чтобы хранить окончательное представление значения `"$199.98"`, поскольку оно уже будет другого типа.

В любом случае, вы заметите, что `amount` хранит текущее значение, которое меняется по ходу выполнения программы, иллюстрируя первичную цель переменных: управление *состоянием* программы.

Другими словами, *состояние* отслеживает изменения значений при выполнении программы.

Еще одно общеупотребительное использование переменных — для централизации установки значений. Обычно это называется *константами*, когда вы объявляете переменную со значением и предполагаете, что это значение не будет меняться в течение работы программы.

Вы объявляете эти *константы*, чаще всего в начале программы, таким образом, чтобы для вас было удобно иметь всего одно место для того, чтобы поменять значение, если нужно. По соглашению, переменные в JavaScript, являющиеся константами, обычно пишутся большими буквами, с подчеркиваниями `_` между словами.

Вот глупый пример:

```js
var TAX_RATE = 0.08;	// 8% налог с продаж

var amount = 99.99;

amount = amount * 2;

amount = amount + (amount * TAX_RATE);

console.log( amount );				// 215.9784
console.log( amount.toFixed( 2 ) );	// "215.98"
```

**Примечание:** Также как `console.log(..)` — это функция `log(..)`, доступная как свойство объекта `console`, `toFixed(..)` здесь — это функция, которая может быть доступна у `числовых` значений. `Число` в JavaScript не форматируется автоматически со знаком валюты — среда выполнения не знает ваших намерений плюс к этому не существует типа для валюты. `toFixed(..)` позволяет нам указать до скольки знаков после запятой мы хотим округлить `число` и она возвращает `строку` при необходимости.

Переменная `TAX_RATE` — всего лишь *константа* по соглашению, в этой программе нет ничего, что могло бы предотвратить ее изменение. Но если ставка налога повысится до 9%, мы все еще можем легко обновить нашу программу установив присвоенное `TAX_RATE` значение в `0.09` всего в одном месте вместо поиска всех вхождений значения `0.08` разбросанных по программе и изменения их всех.

Новейшая версия JavaScript на момент написания этих строк (обычно называемая "ES6") включает в себя новый способ объявления *констант*, используя `const` вместо `var`:

```js
// согласно ES6:
const TAX_RATE = 0.08;

var amount = 99.99;

// ..
```

Константы полезны также как и переменные с неизменяемыми значениями, за исключением того, что константы также предотвращают случайное изменение где-либо после начальной установки значения. Если вы попытаетесь присвоить любое значение в `TAX_RATE` после её объявления, ваша программа отвергнет это изменение (а в строгом (strict) режиме, прервется с ошибкой, см. "Строгий режим" в главе 2).

Кстати, такой тип «защиты» против ошибок похож на контроль типов статической типизации, так что вы в какой-то степени поймете почему статические типы в других языках могут быть привлекательными!

**Примечание:** Для получения более подробной информации о том, как различные значения в переменных могут использоваться в программах, см. книгу *Типы и синтаксис* этой серии.

## Блоки

Сотрудник салона сотовой связи должен пройти последовательность шагов для завершения оформления покупки, если вы покупаете новый телефон.

Примерно также в коде нам часто нужно группировать последовательности операторов вместе, которые мы часто называем  *блоком*. В JavaScript блок определяется обрамлением одного или более операторов парой фигурных скобок `{ .. }`. Пример:

```js
var amount = 99.99;

// отдельный блок
{
	amount = amount * 2;
	console.log( amount );	// 199.98
}
```

Такой вид отдельного блока `{ .. }` вполне допустим, но не часто встречается в JS-программах. Обычно блоки присоединяются к другим управляющим операторам, таким как оператор `if` (см. «Условные конструкции») или цикл (см. «Циклы»). Например:

```js
var amount = 99.99;

// сумма достаточно велика?
if (amount > 10) {			// <-- блок прикрепляется к `if`
	amount = amount * 2;
	console.log( amount );	// 199.98
}
```

Мы расскажем об операторе `if` в следующем разделе, но как вы видите блок `{ .. }` с двумя операторами присоединен к `if (amount > 10)`. Операторы внутри этого блока будут выполнены только при выполнении условия в условной конструкции.

**Примечание:** В отличие от многих других операторов, таких как `console.log(amount);`, блоковый оператор не требует точки с запятой (`;`) в конце оператора.

## Условные конструкции

«Хотите ли вы добавить дополнительную защитную пленку в вашу покупку за $9.99?». Предупредительный сотрудник магазина попросил вас принять решение. И вам может сначала понадобиться проинспектировать текущее *состояние* вашего кошелька или банковского счета, чтобы ответить на этот вопрос. Но, очевидно, что это всего лишь простой вопрос из разряда «да или нет».

Есть довольно много способов, которыми мы можем выразить *условные конструкции* (т.е. решения) в наших программах.

Самый распространенный из них — это оператор `if`. По сути, вы говорите, «*Если* (*if*) это условие истинно, сделать следующее...». Например:

```js
var bank_balance = 302.13;
var amount = 99.99;

if (amount < bank_balance) {
	console.log( "Я хочу купить этот телефон" );
}
```

Оператор `if` требует выражение между скобками `( )`, которое может быть интерпретировано либо как `истина` (`true`), либо `ложь` (`false`). В этой программе мы написали выражение `amount < bank_balance`, которое конечно же будет вычислено как `true` или `false` в зависимости от количества в переменной `bank_balance`.

Вы даже можете предоставить альтернативу если условие не будет истинным, называющуюся оператором `else`. Пример:

```js
const ACCESSORY_PRICE = 9.99;

var bank_balance = 302.13;
var amount = 99.99;

amount = amount * 2;

// может ли мы позволить себе дополнительную покупку?
if ( amount < bank_balance ) {
	console.log( "Я возьму этот аксессуар!" );
	amount = amount + ACCESSORY_PRICE;
}
// иначе:
else {
	console.log( "Нет, спасибо." );
}
```

Тут если `amount < bank_balance` `истинно`, мы выведем `"Я возьму этот аксессуар!"` и добавим `9.99` в нашу переменную `amount`. В противном случае, оператор `else` говорит, что мы вежливо ответим `"Нет, спасибо."` и оставим переменную `amount` без изменений.

Как мы уже обсуждали ранее в «Значения и типы», значения, которые  не совпадают с ожидаемым типом, часто приводятся к этому типу. Оператор `if` ожидает `логическое значение`, но если вы передадите что-либо отличное от `логического значения`, произойдет приведение.

JavaScript определяет список особых значений, которые считаются «ложными», так как при приведении к `логическому значению` они станут значением `false`, такие значения включают в себя `0` и `""`. Любое другое значение, не входящее в список «ложных», автоматически считается «истинным», когда приводится к `логическому значению`, оно становится равным `true`. Истинные значения включают в себя такие значения как `99.99` и `"free"`. См. «Истинный и ложный» в главе 2 для получения более детальной информации.

*Условные конструкции* существуют и в других формах, отличных от `if`. Например, оператор `switch` может использоваться как сокращение для последовательности операторов `if..else` (см. главу 2). Циклы (см. «Циклы») используют *условную конструкцию*, чтобы определить надо ли завершить выполнение цикла или нет.

**Примечание:** Детальную информацию о приведениях, которые происходят неявно в проверочных выражениях *условных конструкций*, см. главу 4 книги *Типы и синтаксис* этой серии.

## Циклы

При большой посещаемости магазина есть очередь из покупателей, которым нужно поговорить с сотрудником магазина. Пока в этой очереди есть люди, сотруднику нужно продолжать обслуживать очередного покупателя.

Повторение набора действий пока не нарушится определенное условие, другими словами, повторение только пока соблюдается условие — это как раз работа для циклов. Циклы могут принимать различные формы, но все они удовлетворяют этому базовому поведению.

Цикл включает в себя проверяемое условие и блок (обычно в виде `{ .. }`). Каждый раз, когда выполняется блок в цикле, это называется  *итерацией*.

Например, цикл `while` и цикл `do..while` иллюстрируют принцип повторения блока операторов до тех пора пока условие не перестанет быть равным `true`:

```js
while (numOfCustomers > 0) {
	console.log( "Чем я могу вам помочь?" );

	// помощь покупателю...

	numOfCustomers = numOfCustomers - 1;
}

// против:

do {
	console.log( "Чем я могу вам помочь?" );

	// помощь покупателю...

	numOfCustomers = numOfCustomers - 1;
} while (numOfCustomers > 0);
```

Единственная разница между этими циклами — это будет ли проверяться условная конструкция до первой итерации (`while`) или после первой итерации (`do..while`).

В любом из этих циклов если условная конструкция возвратит `false`, следующая итерация не будет выполнена. Это значит, что если условие изначально будет `false`, цикл `while` никогда не будет выполнен, а цикл `do..while` выполнится только один раз.

Иногда вы используете цикл для подсчета определенного набора чисел, например от `0` до `9` (десять чисел). Это можно сделать установкой переменной в цикле итерации, например  `i`, в значение `0` и увеличивая его на `1` в каждой итерации.

**Предупреждение:** По множеству исторических причин языки программирования почти всегда ведут подсчет в нолеподобной манере, т.е. начиная с `0` вместо `1`. Если вы не знакомы с таким типом подсчета, поначалу это может сбивать с толку. Уделите некоторое время тому, чтобы попрактиковаться в подсчете, начинающимся с `0`, чтобы освоиться в нем!

Условная конструкция проверяется на каждой итерации, как если бы был неявный оператор `if` внутри цикла.

Для выхода из цикла можно использовать JavaScript-оператор `break`. К тому же, можно обнаружить, что ужасно легко можно создать цикл, который в противном случае будет работать вечно без механизма  `break`.

Проиллюстрируем:

```js
var i = 0;

// цикл `while..true` будет выполняться вечно, не так ли?
while (true) {
	// прервать цикл?
	if ((i <= 9) === false) {
		break;
	}

	console.log( i );
	i = i + 1;
}
// 0 1 2 3 4 5 6 7 8 9
```

**Предупреждение:** Показанное выше не является практикой, которой вы должны придерживаться при реализации ваших циклов. Это представлено только в иллюстративных целях.

Если `while` (или `do..while`) может достичь цели вручную, есть еще одна синтаксическая форма, называемая цикл `for` именно для такой вот цели:

```js
for (var i = 0; i <= 9; i = i + 1) {
	console.log( i );
}
// 0 1 2 3 4 5 6 7 8 9
```

Как видите, в обоих случаях условная конструкция `i <= 9` равна `true` для первых 10 итераций (`i` принимает значения от `0` до `9`) любой из форм цикла, но становится равным `false` как только `i` становится равным `10`.

У цикла `for` есть три составных части: инициализация (`var i=0`), проверка условия (`i <= 9`) и обновление значения (`i = i + 1`). Поэтому если вы собираетесь заниматься выполнением конкретного количества итераций, `for` будет более компактной и часто более легкой формой цикла для понимания и записи.

Есть другие особые формы циклов, которые предназначены для итерирования по особым значениям, таким как свойства объекта (см. главу 2), где неявная проверка условной конструкции — это все ли свойства или нет уже обработаны. Принцип «цикл работает пока не нарушится условие» соблюдается независимо от формы цикла.

## Функции

Сотрудник магазина возможно не носит постоянно с собой калькулятор, чтобы учесть налоги и рассчитать окончательную стоимость покупки. Это задача, которую ему нужно определить один раз и использовать раз за разом. Преимущество в том, что у компании есть контрольно-кассовый аппарат (компьютер, планшет и т.п.), в который эти «функции» уже встроены.

Похожим образом и в вашей программе вам определенно захочется разбить задачи в коде на повторно используемые части, вместо того, чтобы снова и снова однообразно повторять себя. Для реализации этого необходимо определить `функцию`.

Функция — обычно это именованная секция кода, которая может быть «вызвана» по имени и код внутри нее будет при этом запускаться каждый раз. Пример:

```js
function printAmount() {
	console.log( amount.toFixed( 2 ) );
}

var amount = 99.99;

printAmount(); // "99.99"

amount = amount * 2;

printAmount(); // "199.98"
```

У функций могут быть аргументы (т.е. параметры) — это значения которые вы ей передаете. А также функции могут возвращать значение.

```js
function printAmount(amt) {
	console.log( amt.toFixed( 2 ) );
}

function formatAmount() {
	return "$" + amount.toFixed( 2 );
}

var amount = 99.99;

printAmount( amount * 2 );		// "199.98"

amount = formatAmount();
console.log( amount );			// "$99.99"
```

Функция `printAmount(..)` принимает параметр, который мы назвали `amt`. Функция `formatAmount()` возвращает значение. Конечно, вы можете комбинировать параметры и возвращаемое значение в одной и той же функции.

Функции часто используются для кода, который вы планируете вызывать несколько раз, но они также полезны для организации связанных частей кода в именованные наборы, даже если вы будете вызывать их всего лишь раз.

Пример:

```js
const TAX_RATE = 0.08;

function calculateFinalPurchaseAmount(amt) {
	// вычисляем новую сумму с налогом
	amt = amt + (amt * TAX_RATE);

	// возвращаем новую сумму
	return amt;
}

var amount = 99.99;

amount = calculateFinalPurchaseAmount( amount );

console.log( amount.toFixed( 2 ) );		// "107.99"
```

Хотя `calculateFinalPurchaseAmount(..)` вызывается только один раз, выделение её поведения в отдельную именованную функцию делает код, использующий её логику (оператор `amount = calculateFinal...`), яснее. Если в функции есть несколько операторов, её преимущества будут более очевидны.

### Область видимости

Если вы попросите у продавца телефонов модель телефона, которой у магазина нет в продаже, он не сможет продать вам телефон, который вы хотите. У него есть доступ только к телефонам которые есть в наличии в магазине. Вы должны попробовать найти другой магазин, чтобы посмотреть есть ли в нем нужный вам телефон.

В программировании есть термин для этого принципа: *область видимости* (технически называемая *лексическая область видимости*). В JavaScript каждая функция получает свою собственную область видимости. Область видимости — это в основном коллекция переменных и правила доступа к этим переменным по имени. Только код внутри функции имеет доступ к переменным, *действующим в области*  функции.

Имя переменной должно быть уникальным в рамках одной и той же области видимости — не может быть двух различных переменных `a`, расположенных рядом друг с другом. Но одно и тоже имя переменной `a` может появляться в разных областях видимости.

```js
function one() {
	// эта `a` принадлежит только функции `one()`
	var a = 1;
	console.log( a );
}

function two() {
	// эта `a` принадлежит только функции `two()`
	var a = 2;
	console.log( a );
}

one();		// 1
two();		// 2
```

Также, область видимости может быть вложена внутрь другой области видимости, прямо как клоун на дне рождения надувает один шарик внутри другого. Если одна область вложена в другую, для кода внутри самой внутренней области доступны переменные из окружающей области.

Пример:

```js
function outer() {
	var a = 1;

	function inner() {
		var b = 2;

		// здесь у нас есть доступ и к `a`, и к `b`
		console.log( a + b );	// 3
	}

	inner();

	// здесь у нас есть доступ только к  `a`
	console.log( a );			// 1
}

outer();
```

Правила лексической области видимости говорят, что код в одной области может иметь доступ к переменным как её самой, так и к переменным любой области снаружи этой области.

Таким образом, код внутри функции `inner()` имеет доступ к обеим переменным `a` и `b`, но у кода в `outer()` есть доступ только к `a` — у него нет доступа к `b` потому что эта переменная внутри `inner()`.

Вспомните этот код, который появлялся выше:

```js
const TAX_RATE = 0.08;

function calculateFinalPurchaseAmount(amt) {
	// вычисляем новую сумму с налогом
	amt = amt + (amt * TAX_RATE);

	// возвращаем новую сумму
	return amt;
}
```

Константа (переменная) `TAX_RATE` доступна внутри функции `calculateFinalPurchaseAmount(..)`, даже несмотря на то, что мы не передавали её внутрь, из-за лексической области видимости.

**Примечание:** Подробная информация о лексической области видимости есть в первых трех главах книги *Область видимости и замыкания* этой серии.

## Практика

Нет абсолютно никакой адекватной замены практике при обучении программированию. Никакое, даже самое ясное, описание с моей стороны само по себе не сделает из вас программиста.

Держа это в уме, давайте попробуем попрактиковаться в некоторых принципах, которые мы изучили в этой главе. Я дам вам «требования», а вы попробуете их реализовать. Затем сверьтесь с кодом, приведенным ниже, чтобы увидеть как я их реализовал.

* Напишите программу для вычисления общей стоимости покупки телефона. Вы будете продолжать покупать телефоны (подсказка: циклы!) пока у вас не закончатся деньги на банковском счете. Вы также будете покупать аксессуары для каждого из телефонов до тех пор, пока сумма покупки не превысит ваш мысленный предел трат.
* После того, как вы посчитаете сумму покупки, прибавьте налог, затем выведите на экран вычисленную сумму покупки, правильно отформатировав её.
* Наконец, сверьте сумму с балансом вашего банковского счета, чтобы понять можете вы себе это позволить или нет.
* Вы должны настроить некоторые константы для «ставки налога», «цены телефона», «цены аксессуара» и «предела трат» также как и переменную для вашего «баланса банковского счета».
* Вам следует определить функции для вычисления налога и для форматирования цены со знаком валюты и округлением до двух знаков после запятой.
* **Бонусная задача:** Попробуйте включить ввод данных в вашу программу, например с помощью `prompt(..)`, рассмотренную ранее в разделе «Ввод». Вы можете, например, запросить у пользователя баланс банковского счета. Развлекайтесь и будьте изобретательны!

Хорошо, вперед. Попробуйте. Не подсматривайте в мой код пока сами не попробуете!

**Примечание:** Так как это книга о JavaScript, очевидно что я буду решать практические упражнения на JavaScript. Но вы можете сделать это на другом языке, если чувствуете себя в нем более уверенно.

Вот мое решение для этого упражнения, написанное на JavaScript:

```js
const SPENDING_THRESHOLD = 200;
const TAX_RATE = 0.08;
const PHONE_PRICE = 99.99;
const ACCESSORY_PRICE = 9.99;

var bank_balance = 303.91;
var amount = 0;

function calculateTax(amount) {
	return amount * TAX_RATE;
}

function formatAmount(amount) {
	return "$" + amount.toFixed( 2 );
}

// продолжаем покупать телефоны пока у нас остаются деньги
while (amount < bank_balance) {
	// покупаем новый телефон!
	amount = amount + PHONE_PRICE;

	// можем ли мы позволить себе аксессуар?
	if (amount < SPENDING_THRESHOLD) {
		amount = amount + ACCESSORY_PRICE;
	}
}

// не забудьте заплатить налог
amount = amount + calculateTax( amount );

console.log(
	"Ваша покупка: " + formatAmount( amount )
);
// Ваша покупка: $334.76

// можете ли вы в самом деле позволить себе эту покупку?
if (amount > bank_balance) {
	console.log(
		"Вы не можете позволить себе эту покупку. :("
	);
}
// Вы не можете позволить себе эту покупку. :(
```

**Примечание:** Простейший способ запустить эту JavaScript программу — набрать её в консоли разработчика в вашем браузере.

Как у вас получилось? Не так уж сложно попробовать снова теперь, когда вы увидели мой код. И поиграть с изменением констант, чтобы увидеть как программа работает с разными значениями.
